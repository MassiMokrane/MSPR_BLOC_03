# import os
# import pandas as pd

# # === CONFIGURATION DES CHEMINS ===
# # Chemins des fichiers sources (ajustez selon vos chemins)
# fichier_2022 = "C:/Users/Massi/Desktop/MSPR BLOC 03/Nettoyage/DATA_Nettoyer/DATA_tour-1/DATA_Nettoyer_t1_2022.xlsx"
# fichier_2017 = "C:/Users/Massi/Desktop/MSPR BLOC 03/Nettoyage/DATA_Nettoyer/DATA_tour-1/DATA_Nettoyer_t1_2017.xlsx"

# # Dossier de sortie pour le fichier fusionn√©
# dossier_sortie = "C:/Users/Massi/Desktop/MSPR BLOC 03/Nettoyage/DATA_Nettoyer/DATA_Fusionnees"

# print("=== FUSION DES DATASETS 2022 ET 2017 ===")
# print("=" * 50)

# # === 1. CHARGER LES DEUX DATASETS ===
# try:
#     print("üìÇ Chargement du dataset 2022...")
#     df_2022 = pd.read_excel(fichier_2022)
#     print(f"   ‚úÖ Dataset 2022 charg√© : {len(df_2022)} lignes, {len(df_2022.columns)} colonnes")
    
#     print("üìÇ Chargement du dataset 2017...")
#     df_2017 = pd.read_excel(fichier_2017)
#     print(f"   ‚úÖ Dataset 2017 charg√© : {len(df_2017)} lignes, {len(df_2017.columns)} colonnes")
    
# except FileNotFoundError as e:
#     print(f"‚ùå Erreur : Fichier non trouv√© - {e}")
#     print("V√©rifiez les chemins des fichiers dans le code.")
#     exit()

# # === 2. V√âRIFICATION DE LA COMPATIBILIT√â ===
# print("\nüîç V√©rification de la compatibilit√© des datasets...")

# # V√©rifier si les colonnes sont identiques
# colonnes_2022 = set(df_2022.columns)
# colonnes_2017 = set(df_2017.columns)

# if colonnes_2022 == colonnes_2017:
#     print("   ‚úÖ Les colonnes sont identiques dans les deux datasets")
# else:
#     print("   ‚ö†Ô∏è  Diff√©rences d√©tect√©es dans les colonnes :")
#     colonnes_uniquement_2022 = colonnes_2022 - colonnes_2017
#     colonnes_uniquement_2017 = colonnes_2017 - colonnes_2022
    
#     if colonnes_uniquement_2022:
#         print(f"      Uniquement dans 2022 : {list(colonnes_uniquement_2022)}")
#     if colonnes_uniquement_2017:
#         print(f"      Uniquement dans 2017 : {list(colonnes_uniquement_2017)}")

# # Afficher les colonnes communes
# colonnes_communes = list(colonnes_2022.intersection(colonnes_2017))
# print(f"   üìã Colonnes communes : {len(colonnes_communes)}")

# # === 3. AFFICHAGE DES INFORMATIONS AVANT FUSION ===
# print("\nüìä Informations avant fusion :")
# print(f"   Dataset 2022 : {len(df_2022)} communes")
# print(f"   Dataset 2017 : {len(df_2017)} communes")

# # === 4. FUSION DES DATASETS ===
# print("\nüîó Fusion des datasets en cours...")

# # M√©thode 1 : Si les colonnes sont identiques
# if colonnes_2022 == colonnes_2017:
#     # Fusion simple : 2022 en haut, 2017 en bas
#     df_fusionne = pd.concat([df_2022, df_2017], ignore_index=True)
# else:
#     # M√©thode 2 : Si les colonnes diff√®rent, on utilise les colonnes communes
#     print("   ‚öôÔ∏è  Utilisation des colonnes communes pour la fusion...")
#     df_2022_filtre = df_2022[colonnes_communes]
#     df_2017_filtre = df_2017[colonnes_communes]
#     df_fusionne = pd.concat([df_2022_filtre, df_2017_filtre], ignore_index=True)

# print(f"   ‚úÖ Fusion termin√©e : {len(df_fusionne)} lignes au total")

# # === 5. V√âRIFICATION DE LA FUSION ===
# print("\nüîç V√©rification de la fusion :")

# # Compter les lignes par ann√©e
# repartition_annees = df_fusionne['Ann√©e'].value_counts().sort_index()
# print("   üìä R√©partition par ann√©e :")
# for annee, count in repartition_annees.items():
#     print(f"      {annee} : {count} communes")

# # V√©rifier s'il y a des doublons d'ID Commune pour la m√™me ann√©e
# doublons_par_annee = df_fusionne.groupby('Ann√©e')['ID Commune'].apply(lambda x: x.duplicated().sum())
# print("\n   üîç V√©rification des doublons par ann√©e :")
# for annee, nb_doublons in doublons_par_annee.items():
#     if nb_doublons > 0:
#         print(f"      ‚ö†Ô∏è  {annee} : {nb_doublons} doublons d√©tect√©s")
#     else:
#         print(f"      ‚úÖ {annee} : Aucun doublon")

# # === 6. STATISTIQUES DESCRIPTIVES ===
# print("\nüìà Statistiques du dataset fusionn√© :")
# print(f"   Nombre total de lignes : {len(df_fusionne)}")
# print(f"   Nombre de colonnes : {len(df_fusionne.columns)}")
# print(f"   Colonnes : {list(df_fusionne.columns)}")

# # V√©rifier les valeurs manquantes
# print("\n   üìã Valeurs manquantes par colonne :")
# valeurs_manquantes = df_fusionne.isnull().sum()
# for col, nb_nan in valeurs_manquantes.items():
#     if nb_nan > 0:
#         print(f"      {col} : {nb_nan} valeurs manquantes")

# # === 7. R√âORGANISATION FINALE ===
# print("\nüîÑ R√©organisation finale...")

# # S'assurer que les donn√©es sont tri√©es : 2022 d'abord, puis 2017
# df_fusionne = df_fusionne.sort_values(['Ann√©e', 'ID Commune'], ascending=[False, True])
# df_fusionne = df_fusionne.reset_index(drop=True)

# print("   ‚úÖ Donn√©es tri√©es : 2022 en premier, puis 2017")

# # === 8. SAUVEGARDE ===
# def sauvegarder_fichiers(df, nom_base, dossier):
#     """Sauvegarde le dataframe en Excel et CSV"""
#     os.makedirs(dossier, exist_ok=True)
    
#     # Sauvegarde Excel
#     chemin_excel = os.path.join(dossier, f"{nom_base}.xlsx")
#     try:
#         df.to_excel(chemin_excel, index=False, engine='openpyxl')
#         print(f"   ‚úÖ Fichier Excel sauvegard√© : {chemin_excel}")
#     except Exception as e:
#         print(f"   ‚ùå Erreur Excel : {e}")
    
#     # Sauvegarde CSV
#     chemin_csv = os.path.join(dossier, f"{nom_base}.csv")
#     try:
#         df.to_csv(chemin_csv, index=False, encoding='utf-8-sig', sep=';')
#         print(f"   ‚úÖ Fichier CSV sauvegard√© : {chemin_csv}")
#     except Exception as e:
#         print(f"   ‚ùå Erreur CSV : {e}")
    
#     return chemin_excel, chemin_csv

# print("\nüíæ Sauvegarde des fichiers fusionn√©s...")
# nom_fichier_fusionne = "DATA_Fusionnees_2022_2017"
# chemin_excel, chemin_csv = sauvegarder_fichiers(df_fusionne, nom_fichier_fusionne, dossier_sortie)

# # === 9. RAPPORT FINAL ===
# print("\n" + "=" * 50)
# print("üìã RAPPORT FINAL DE FUSION")
# print("=" * 50)
# print(f"‚úÖ Fusion r√©ussie !")
# print(f"üìä Dataset final : {len(df_fusionne)} lignes")
# print(f"üóìÔ∏è  Ann√©es : {sorted(df_fusionne['Ann√©e'].unique(), reverse=True)}")
# print(f"üèõÔ∏è  Communes uniques : {df_fusionne['ID Commune'].nunique()}")
# print(f"üìÅ Fichiers g√©n√©r√©s :")
# print(f"   üìÑ Excel : {chemin_excel}")
# print(f"   üìÑ CSV   : {chemin_csv}")

# # Aper√ßu des premi√®res lignes
# print(f"\nüëÄ Aper√ßu des 5 premi√®res lignes :")
# print(df_fusionne[['ID Commune', 'Ann√©e', 'Nom Complet √âlu', 'Parti Politique √âlu']].head())

# print("\nüéâ Fusion termin√©e avec succ√®s !")
# print("=" * 50)
import os
import pandas as pd

# === CONFIGURATION DES CHEMINS ===
fichier_2022 = "C:/Users/Massi/Desktop/MSPR BLOC 03/Nettoyage/DATA_Nettoyer/Data_elections/DATA_Nettoyer_t1_2022.xlsx"
fichier_2017 = "C:/Users/Massi/Desktop/MSPR BLOC 03/Nettoyage/DATA_Nettoyer/DATA_elections/DATA_Nettoyer_t1_2017.xlsx"
dossier_sortie = "C:/Users/Massi/Desktop/MSPR BLOC 03/Nettoyage/DATA_Nettoyer/DATA_Fusionnees"

print("=== FUSION DES DATASETS PAR ID COMMUNE ===")
print("=" * 50)

# === CHARGEMENT ===
try:
    print("üìÇ Chargement des datasets...")
    df_2022 = pd.read_excel(fichier_2022)
    df_2017 = pd.read_excel(fichier_2017)
except FileNotFoundError as e:
    print(f"‚ùå Fichier non trouv√© : {e}")
    exit()

# === VERIFICATION COLONNES ===
colonnes_2022 = set(df_2022.columns)
colonnes_2017 = set(df_2017.columns)
colonnes_communes = list(colonnes_2022 & colonnes_2017)

if colonnes_2022 != colonnes_2017:
    print("‚ö†Ô∏è Colonnes diff√©rentes, utilisation des colonnes communes.")

df_2022 = df_2022[colonnes_communes].copy()
df_2017 = df_2017[colonnes_communes].copy()

# S'assurer que la colonne "Ann√©e" existe
if "Ann√©e" not in df_2022.columns:
    df_2022["Ann√©e"] = 2022
if "Ann√©e" not in df_2017.columns:
    df_2017["Ann√©e"] = 2017

# === FUSION ALTERN√âE PAR ID COMMUNE ===
print("üîó Fusion altern√©e par ID Commune...")

# Fusion sur ID Commune
df_2022_sorted = df_2022.sort_values("ID Commune")
df_2017_sorted = df_2017.sort_values("ID Commune")

# Faire un merge outer pour capturer toutes les communes des deux ann√©es
ids_communes = pd.Series(sorted(set(df_2022["ID Commune"]) | set(df_2017["ID Commune"])))

# Cr√©er une liste de lignes fusionn√©es
fusion_lignes = []
for id_commune in ids_communes:
    ligne_2022 = df_2022_sorted[df_2022_sorted["ID Commune"] == id_commune]
    ligne_2017 = df_2017_sorted[df_2017_sorted["ID Commune"] == id_commune]
    if not ligne_2022.empty:
        fusion_lignes.append(ligne_2022)
    if not ligne_2017.empty:
        fusion_lignes.append(ligne_2017)

df_fusionne = pd.concat(fusion_lignes, ignore_index=True)

# === TRI FINAL ===
df_fusionne = df_fusionne.sort_values(["ID Commune", "Ann√©e"], ascending=[True, False]).reset_index(drop=True)
# === R√âORGANISATION DES COLONNES DANS L‚ÄôORDRE SOUHAIT√â ===
ordre_colonnes = [
    "ID Commune", "Ann√©e", "Inscrits", "% Voix/Ins √âlu", "% Voix/Exp √âlu", "Abstentions",
    "Sexe √âlu", "Nom Complet √âlu", "Voix √âlu", "Parti Politique √âlu", "Orientation Politique", "Score Orientation (0 √† 4)"
]

# Filtrer uniquement les colonnes pr√©sentes dans le DataFrame
colonnes_finales = [col for col in ordre_colonnes if col in df_fusionne.columns]
df_fusionne = df_fusionne[colonnes_finales]

# === SAUVEGARDE ===
def sauvegarder(df, nom_base, dossier):
    os.makedirs(dossier, exist_ok=True)
    chemin_xlsx = os.path.join(dossier, nom_base + ".xlsx")
    chemin_csv = os.path.join(dossier, nom_base + ".csv")

    df.to_excel(chemin_xlsx, index=False, engine='openpyxl')
    df.to_csv(chemin_csv, index=False, sep=';', encoding='utf-8-sig')
    
    return chemin_xlsx, chemin_csv

print("\nüíæ Sauvegarde du fichier fusionn√©...")
nom_fichier = "DATA_Nettoyer_Elections"
chemin_excel, chemin_csv = sauvegarder(df_fusionne, nom_fichier, dossier_sortie)

# === RAPPORT FINAL ===
print("\nüìã RAPPORT FINAL")
print("=" * 50)
print(f"‚úÖ Fusion altern√©e r√©ussie")
print(f"üìÑ Excel : {chemin_excel}")
print(f"üìÑ CSV   : {chemin_csv}")
print(f"üìä Lignes : {len(df_fusionne)}")
print(f"üóìÔ∏è  Ann√©es incluses : {df_fusionne['Ann√©e'].unique()}")
print(f"üèõÔ∏è  Communes uniques : {df_fusionne['ID Commune'].nunique()}")
print("=" * 50)
